{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { isNullOrUndefined, setStyleAttribute, extend, EventHandler, createElement } from '@syncfusion/ej2-base';\nimport * as cls from '../base/css-constant';\nimport * as util from '../base/util';\nimport { MonthEvent } from './month';\nvar EVENT_GAP = 2;\nvar BLOCK_INDICATOR_WIDTH = 22;\nvar BLOCK_INDICATOR_HEIGHT = 18;\n/**\n * Timeline view events render\n */\n\nvar TimelineEvent =\n/** @class */\nfunction (_super) {\n  __extends(TimelineEvent, _super);\n  /**\n   * Constructor for timeline views\n   */\n\n\n  function TimelineEvent(parent, type) {\n    var _this = _super.call(this, parent) || this;\n\n    _this.startHour = _this.parent.activeView.getStartHour();\n    _this.endHour = _this.parent.activeView.getEndHour();\n    _this.slotCount = _this.parent.activeViewOptions.timeScale.slotCount;\n    _this.interval = _this.parent.activeViewOptions.timeScale.interval;\n    _this.day = 0;\n    _this.rowIndex = 0;\n    _this.renderType = type;\n    _this.appContainers = [].slice.call(_this.element.querySelectorAll('.' + cls.APPOINTMENT_CONTAINER_CLASS));\n    _this.dayLength = _this.element.querySelectorAll('.' + cls.CONTENT_TABLE_CLASS + ' tbody tr')[0].children.length;\n    _this.content = _this.parent.element.querySelector('.' + cls.CONTENT_TABLE_CLASS);\n    return _this;\n  }\n\n  TimelineEvent.prototype.getSlotDates = function () {\n    this.slots = [];\n    this.slots.push(this.parent.activeView.renderDates.map(function (date) {\n      return +date;\n    }));\n\n    if (this.parent.headerRows.length > 0 && this.parent.headerRows[this.parent.headerRows.length - 1].option !== 'Hour') {\n      this.renderType = 'day';\n      this.cellWidth = this.content.offsetWidth / this.dateRender.length;\n      this.slotsPerDay = 1;\n    } else {\n      this.slotsPerDay = this.dayLength / this.dateRender.length;\n    }\n  };\n\n  TimelineEvent.prototype.getOverlapEvents = function (date, appointments) {\n    var appointmentsList = [];\n\n    if (this.renderType === 'day') {\n      for (var _i = 0, appointments_1 = appointments; _i < appointments_1.length; _i++) {\n        var app = appointments_1[_i];\n\n        if (util.resetTime(app[this.fields.startTime]).getTime() <= util.resetTime(new Date(date.getTime())).getTime() && util.resetTime(app[this.fields.endTime]).getTime() >= util.resetTime(new Date(date.getTime())).getTime()) {\n          appointmentsList.push(app);\n        }\n      }\n    } else {\n      for (var _a = 0, appointments_2 = appointments; _a < appointments_2.length; _a++) {\n        var app = appointments_2[_a];\n        var eventData = app.data;\n\n        if (eventData.trimStartTime.getTime() <= date.getTime() && eventData.trimEndTime.getTime() > date.getTime()) {\n          appointmentsList.push(app);\n        }\n      }\n    }\n\n    return appointmentsList;\n  };\n\n  TimelineEvent.prototype.renderResourceEvents = function () {\n    this.removeHeightProperty(cls.RESOURCE_COLUMN_TABLE_CLASS);\n    var resources = this.parent.uiStateValues.isGroupAdaptive ? [this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex]] : this.parent.resourceBase.renderedResources;\n\n    for (var i = 0; i < resources.length; i++) {\n      this.rowIndex = i;\n      this.renderEventsHandler(this.parent.activeView.renderDates, this.parent.activeViewOptions.workDays, resources[i]);\n    }\n  };\n\n  TimelineEvent.prototype.renderEvents = function (event, resIndex, eventsList) {\n    var eventData = event.data;\n    var startTime = this.getStartTime(event, eventData);\n    var endTime = this.getEndTime(event, eventData);\n    this.day = this.parent.getIndexOfDate(this.dateRender, util.resetTime(new Date(startTime.getTime())));\n\n    if (this.day < 0) {\n      return;\n    }\n\n    var cellTd = this.getCellTd();\n    var overlapCount = this.getIndex(startTime);\n    event.Index = overlapCount;\n    var appHeight = this.eventHeight;\n    var diffInDays = eventData.count;\n\n    if (startTime <= endTime) {\n      var appWidth = this.getEventWidth(startTime, endTime, event[this.fields.isAllDay], diffInDays);\n      appWidth = this.renderType === 'day' ? appWidth - 2 : appWidth;\n      var appLeft = 0;\n      var appRight = 0;\n      var position = this.getPosition(startTime, endTime, event[this.fields.isAllDay], this.day);\n      appWidth = appWidth <= 0 ? this.cellWidth : appWidth; // appWidth 0 when start and end time as same\n\n      this.renderedEvents.push(extend({}, event, null, true));\n      var top_1 = this.getRowTop(resIndex);\n      var appTop = top_1 + EVENT_GAP + overlapCount * (appHeight + EVENT_GAP);\n      appLeft = this.parent.enableRtl ? 0 : position;\n      appRight = this.parent.enableRtl ? position : 0;\n      var height = (overlapCount + 1) * (appHeight + EVENT_GAP) + this.moreIndicatorHeight;\n\n      if (this.cellHeight > height || this.parent.rowAutoHeight) {\n        var appointmentElement = this.createAppointmentElement(event, resIndex);\n        this.applyResourceColor(appointmentElement, event, 'backgroundColor', this.groupOrder);\n        setStyleAttribute(appointmentElement, {\n          'width': appWidth + 'px',\n          'left': appLeft + 'px',\n          'right': appRight + 'px',\n          'top': appTop + 'px'\n        });\n        this.wireAppointmentEvents(appointmentElement, event);\n        this.renderEventElement(event, appointmentElement, cellTd);\n\n        if (this.parent.rowAutoHeight) {\n          var firstChild = this.getFirstChild(resIndex);\n          this.updateCellHeight(firstChild, height);\n        }\n      } else {\n        for (var i = 0; i < diffInDays; i++) {\n          var moreIndicator = cellTd.querySelector('.' + cls.MORE_INDICATOR_CLASS);\n          var appPos = this.parent.enableRtl ? appRight : appLeft;\n          appPos = Math.floor(appPos / this.cellWidth) * this.cellWidth;\n\n          if (cellTd && isNullOrUndefined(moreIndicator) || !this.isAlreadyAvail(appPos, cellTd)) {\n            var interval = this.interval / this.slotCount;\n            var startDate = new Date(this.dateRender[this.day + i].getTime());\n            var endDate = util.addDays(this.dateRender[this.day + i], 1);\n            var startDateTime = new Date(+startTime);\n            var slotStartTime = new Date(startDateTime.setMinutes(Math.floor(startDateTime.getMinutes() / interval) * interval));\n            var slotEndTime = new Date(slotStartTime.getTime() + 60000 * interval);\n            var groupIndex = void 0;\n\n            if (this.parent.activeViewOptions.group.resources.length > 0 && !isNullOrUndefined(resIndex)) {\n              groupIndex = resIndex.toString();\n            }\n\n            var filterEvents = this.getFilterEvents(startDate, endDate, slotStartTime, slotEndTime, groupIndex, eventsList);\n            var appArea = this.cellHeight - this.moreIndicatorHeight;\n            var renderedAppCount = Math.floor(appArea / (appHeight + EVENT_GAP));\n            var count = filterEvents.length - renderedAppCount <= 0 ? 1 : filterEvents.length - renderedAppCount;\n            var moreIndicatorElement = void 0;\n\n            if (this.renderType === 'day') {\n              moreIndicatorElement = this.getMoreIndicatorElement(count, startDate, endDate);\n            } else {\n              moreIndicatorElement = this.getMoreIndicatorElement(count, slotStartTime, slotEndTime);\n            }\n\n            if (!isNullOrUndefined(groupIndex)) {\n              moreIndicatorElement.setAttribute('data-group-index', groupIndex);\n            }\n\n            moreIndicatorElement.style.top = top_1 + appArea + 'px';\n            moreIndicatorElement.style.width = this.cellWidth + 'px';\n            moreIndicatorElement.style.left = Math.floor(appLeft / this.cellWidth) * this.cellWidth + 'px';\n            moreIndicatorElement.style.right = Math.floor(appRight / this.cellWidth) * this.cellWidth + 'px';\n            this.renderElement(cellTd, moreIndicatorElement);\n            EventHandler.add(moreIndicatorElement, 'click', this.moreIndicatorClick, this);\n          }\n        }\n      }\n    }\n  };\n\n  TimelineEvent.prototype.updateCellHeight = function (cell, height) {\n    if (height > cell.offsetHeight) {\n      setStyleAttribute(cell, {\n        'height': height + 'px'\n      });\n\n      if (this.parent.activeViewOptions.group.resources.length > 0) {\n        var resourceCell = this.parent.element.querySelector('.' + cls.RESOURCE_COLUMN_TABLE_CLASS + ' ' + 'tbody td[data-group-index=\"' + cell.getAttribute('data-group-index') + '\"]');\n        setStyleAttribute(resourceCell, {\n          'height': height + 'px'\n        });\n      }\n    }\n  };\n\n  TimelineEvent.prototype.getFirstChild = function (index) {\n    var query = '.' + cls.CONTENT_TABLE_CLASS + ' tbody td';\n    var groupIndex = '';\n\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      groupIndex = '[data-group-index=\"' + index.toString() + '\"]';\n    }\n\n    var td = this.parent.element.querySelector(query + groupIndex);\n    return td;\n  };\n\n  TimelineEvent.prototype.updateBlockElements = function () {\n    var blockElement = [].slice.call(this.element.querySelectorAll('.' + cls.BLOCK_APPOINTMENT_CLASS));\n\n    for (var _i = 0, blockElement_1 = blockElement; _i < blockElement_1.length; _i++) {\n      var element = blockElement_1[_i];\n      var resIndex = parseInt(element.getAttribute('data-group-index'), 10);\n      var firstChild = this.getFirstChild(resIndex);\n      element.style.height = firstChild.offsetHeight + 'px';\n      var width = Math.round(element.offsetWidth / firstChild.offsetWidth);\n      element.style.width = firstChild.offsetWidth * width + 'px';\n    }\n\n    var blockIndicator = [].slice.call(this.element.querySelectorAll('.' + cls.BLOCK_INDICATOR_CLASS));\n\n    for (var _a = 0, blockIndicator_1 = blockIndicator; _a < blockIndicator_1.length; _a++) {\n      var element = blockIndicator_1[_a];\n      var resIndex = parseInt(element.getAttribute('data-group-index'), 10);\n      element.style.top = this.getRowTop(resIndex) + this.getFirstChild(resIndex).offsetHeight - BLOCK_INDICATOR_HEIGHT + 'px';\n    }\n  };\n\n  TimelineEvent.prototype.getStartTime = function (event, eventData) {\n    var startTime = event[this.fields.startTime];\n    var schedule = util.getStartEndHours(startTime, this.startHour, this.endHour);\n\n    if (schedule.startHour.getTime() >= eventData[this.fields.startTime]) {\n      startTime = schedule.startHour;\n    } else if (schedule.endHour.getTime() <= eventData[this.fields.startTime]) {\n      startTime = this.getNextDay(schedule.startHour, eventData);\n    } else {\n      startTime = eventData[this.fields.startTime];\n    } // To overcome the overflow\n\n\n    eventData.trimStartTime = event[this.fields.isAllDay] ? schedule.startHour : eventData[this.fields.startTime];\n    return startTime;\n  };\n\n  TimelineEvent.prototype.getNextDay = function (startTime, eventData) {\n    var startDate;\n\n    for (var i = 1; i <= this.dateRender.length; i++) {\n      startDate = util.addDays(startTime, i);\n\n      if (this.parent.getIndexOfDate(this.dateRender, util.resetTime(new Date(startTime.getTime()))) !== -1) {\n        eventData.count = eventData.count - 1;\n        return startDate;\n      }\n    }\n\n    return startDate;\n  };\n\n  TimelineEvent.prototype.getEndTime = function (event, eventData) {\n    var endTime = event[this.fields.endTime];\n    var schedule = util.getStartEndHours(endTime, this.startHour, this.endHour);\n\n    if (schedule.endHour.getTime() <= eventData[this.fields.endTime]) {\n      endTime = schedule.endHour;\n    } else {\n      endTime = eventData[this.fields.endTime];\n    } // To overcome the overflow\n\n\n    eventData.trimEndTime = event[this.fields.isAllDay] ? schedule.endHour : eventData[this.fields.endTime];\n    return endTime;\n  };\n\n  TimelineEvent.prototype.getEventWidth = function (startDate, endDate, isAllDay, count) {\n    if (this.renderType === 'day' || isAllDay) {\n      return count * this.slotsPerDay * this.cellWidth;\n    }\n\n    if (this.isSameDay(startDate, endDate)) {\n      return this.getSameDayEventsWidth(startDate, endDate);\n    } else {\n      return this.getSpannedEventsWidth(startDate, endDate, count);\n    }\n  };\n\n  TimelineEvent.prototype.getSameDayEventsWidth = function (startDate, endDate) {\n    return (endDate.getTime() - startDate.getTime()) / (60 * 1000) * (this.cellWidth * this.slotCount) / this.interval;\n  };\n\n  TimelineEvent.prototype.getSpannedEventsWidth = function (startDate, endDate, diffInDays) {\n    var width = diffInDays * this.slotsPerDay * this.cellWidth;\n    var startWidth;\n    var endWidth;\n    var start = util.getStartEndHours(util.resetTime(new Date(startDate.getTime())), this.startHour, this.endHour);\n    startWidth = this.getSameDayEventsWidth(start.startHour, startDate);\n\n    if (this.parent.getIndexOfDate(this.dateRender, util.resetTime(new Date(endDate.getTime()))) === -1) {\n      endWidth = 0;\n    } else {\n      var end = util.getStartEndHours(util.resetTime(new Date(endDate.getTime())), this.startHour, this.endHour);\n      endWidth = this.getSameDayEventsWidth(endDate, end.endHour);\n      endWidth = this.slotsPerDay * this.cellWidth === endWidth ? 0 : endWidth;\n    }\n\n    var spannedWidth = startWidth + endWidth;\n    return width > spannedWidth ? width - spannedWidth : endWidth - startWidth;\n  };\n\n  TimelineEvent.prototype.isSameDay = function (startTime, endTime) {\n    var startDay = this.parent.getIndexOfDate(this.dateRender, util.resetTime(new Date(startTime.getTime())));\n    var endDay = this.parent.getIndexOfDate(this.dateRender, util.resetTime(new Date(endTime.getTime())));\n    return startDay === endDay;\n  };\n\n  TimelineEvent.prototype.getAppointmentLeft = function (schedule, startTime, day) {\n    var slotTd = this.isSameDay(startTime, schedule.startHour) ? (startTime.getTime() - schedule.startHour.getTime()) / (60 * 1000 * this.interval) * this.slotCount : 0;\n\n    if (day === 0) {\n      return slotTd;\n    } else {\n      var daySlot = (schedule.endHour.getTime() - schedule.startHour.getTime()) / (60 * 1000) / this.interval * this.slotCount;\n      return daySlot * day + slotTd;\n    }\n  };\n\n  TimelineEvent.prototype.getPosition = function (startTime, endTime, isAllDay, day) {\n    if (this.renderType === 'day' || isAllDay) {\n      return day * this.slotsPerDay * this.cellWidth;\n    }\n\n    var currentDate = util.resetTime(new Date(this.dateRender[day].getTime()));\n    var schedule = util.getStartEndHours(currentDate, this.startHour, this.endHour);\n    var cellIndex;\n\n    if (schedule.endHour.getTime() <= endTime.getTime() && schedule.startHour.getTime() >= startTime.getTime()) {\n      cellIndex = this.getAppointmentLeft(schedule, schedule.startHour, day);\n    } else if (schedule.endHour.getTime() <= endTime.getTime()) {\n      cellIndex = this.getAppointmentLeft(schedule, startTime, day);\n    } else if (schedule.startHour.getTime() >= startTime.getTime()) {\n      cellIndex = this.getAppointmentLeft(schedule, schedule.startHour, day);\n    } else {\n      cellIndex = this.getAppointmentLeft(schedule, startTime, day);\n    }\n\n    return cellIndex * this.cellWidth;\n  }; //tslint:disable-next-line:max-line-length\n\n\n  TimelineEvent.prototype.getFilterEvents = function (startDate, endDate, startTime, endTime, gIndex, eventsList) {\n    if (this.renderType === 'day') {\n      return this.getFilteredEvents(startDate, endDate, gIndex, eventsList);\n    } else {\n      return this.getFilteredEvents(startTime, endTime, gIndex, eventsList);\n    }\n  };\n\n  TimelineEvent.prototype.isAlreadyAvail = function (appPos, cellTd) {\n    var moreIndicator = [].slice.call(cellTd.querySelectorAll('.' + cls.MORE_INDICATOR_CLASS));\n\n    for (var i = 0; i < moreIndicator.length; i++) {\n      var indicatorPos = void 0;\n\n      if (moreIndicator) {\n        indicatorPos = this.parent.enableRtl ? moreIndicator[i].style.right : moreIndicator[i].style.left;\n      }\n\n      if (parseInt(indicatorPos, 10) === Math.floor(appPos)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  TimelineEvent.prototype.getRowTop = function (resIndex) {\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      var td = this.parent.element.querySelector('.' + cls.CONTENT_WRAP_CLASS + ' ' + 'tbody td[data-group-index=\"' + resIndex.toString() + '\"]');\n      return td.offsetTop;\n    }\n\n    return 0;\n  };\n\n  TimelineEvent.prototype.getCellTd = function () {\n    var wrapIndex = this.parent.uiStateValues.isGroupAdaptive ? 0 : this.rowIndex;\n    return this.appContainers[wrapIndex];\n  };\n\n  TimelineEvent.prototype.renderBlockIndicator = function (cellTd, position, resIndex) {\n    // No need to render block icon for Year, Month and Week header rows\n    if (this.parent.headerRows.length > 0 && (this.parent.headerRows[this.parent.headerRows.length - 1].option !== 'Hour' || this.parent.headerRows[this.parent.headerRows.length - 1].option !== 'Date')) {\n      return;\n    }\n\n    position = Math.floor(position / this.cellWidth) * this.cellWidth + this.cellWidth - BLOCK_INDICATOR_WIDTH;\n\n    if (!this.isAlreadyAvail(position, cellTd)) {\n      var blockIndicator = createElement('div', {\n        className: 'e-icons ' + cls.BLOCK_INDICATOR_CLASS\n      });\n\n      if (this.parent.activeViewOptions.group.resources.length > 0) {\n        blockIndicator.setAttribute('data-group-index', resIndex.toString());\n      }\n\n      if (this.parent.enableRtl) {\n        blockIndicator.style.right = position + 'px';\n      } else {\n        blockIndicator.style.left = position + 'px';\n      }\n\n      blockIndicator.style.top = this.getRowTop(resIndex) + this.cellHeight - BLOCK_INDICATOR_HEIGHT + 'px';\n      this.renderElement(cellTd, blockIndicator);\n    }\n  };\n\n  return TimelineEvent;\n}(MonthEvent);\n\nexport { TimelineEvent };","map":null,"metadata":{},"sourceType":"module"}