{"ast":null,"code":"import { isNullOrUndefined, extend } from '@syncfusion/ej2-base';\nimport { DataManager, Query } from '@syncfusion/ej2-data';\nimport { getRecurrenceStringFromDate } from '../../recurrence-editor/date-generator';\n/**\n * ICalendar Import Module\n */\n\nvar ICalendarImport =\n/** @class */\nfunction () {\n  function ICalendarImport(parent) {\n    this.allDay = false;\n    this.parent = parent;\n  }\n\n  ICalendarImport.prototype.initializeCalendarImport = function (fileContent) {\n    var _this = this;\n\n    if (fileContent) {\n      var fileReader_1 = new FileReader();\n\n      fileReader_1.onload = function (event) {\n        var iCalString = fileReader_1.result;\n\n        _this.iCalendarParser(iCalString);\n      };\n\n      fileReader_1.readAsText(fileContent, 'ISO-8859-8');\n    }\n  };\n\n  ICalendarImport.prototype.iCalendarParser = function (iCalString) {\n    var _this = this;\n\n    var fields = this.parent.eventFields;\n    var events = [];\n    var uId = 'UID';\n    var calArray = iCalString.replace(new RegExp('\\\\r', 'g'), '').split('\\n');\n    var isEvent = false;\n    var curEvent = null;\n    var id = this.parent.eventBase.getEventMaxID();\n    calArray.forEach(function (element) {\n      var index;\n      var type;\n      var value;\n\n      if (!isEvent && element === 'BEGIN:VEVENT') {\n        isEvent = true;\n        curEvent = {};\n      }\n\n      if (isEvent && element === 'END:VEVENT') {\n        isEvent = false;\n        events.push(curEvent);\n        curEvent = null;\n      }\n\n      if (isEvent) {\n        index = element.indexOf(':');\n        type = element.substr(0, index).replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n        value = element.substr(index + 1, element.length - (index + 1)).replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\n        if (element.indexOf('SUMMARY') !== -1) {\n          type = 'SUMMARY';\n        }\n\n        if (element.indexOf('DTSTART') !== -1) {\n          curEvent[fields.startTime] = _this.dateParsing(element);\n          curEvent[fields.isAllDay] = _this.allDay;\n          _this.allDay = false;\n        } else if (element.indexOf('DTEND') !== -1) {\n          curEvent[fields.endTime] = _this.dateParsing(element);\n        } else if (element.indexOf('EXDATE') !== -1) {\n          value = getRecurrenceStringFromDate(_this.dateParsing(element));\n          curEvent[fields.recurrenceException] = isNullOrUndefined(curEvent[fields.recurrenceException]) ? value : curEvent[fields.recurrenceException] + ',' + value;\n        } else if (element.indexOf('RECURRENCE-ID') !== -1) {\n          value = getRecurrenceStringFromDate(_this.dateParsing(element));\n          curEvent[fields.recurrenceException] = value;\n          curEvent[fields.recurrenceID] = value;\n        } else {\n          switch (type) {\n            case 'BEGIN':\n              break;\n\n            case 'UID':\n              curEvent[uId] = value;\n              curEvent[fields.id] = id++;\n              break;\n\n            case 'SUMMARY':\n              curEvent[fields.subject] = value;\n              break;\n\n            case 'LOCATION':\n              curEvent[fields.location] = value;\n              break;\n\n            case 'DESCRIPTION':\n              curEvent[fields.description] = value;\n              break;\n\n            case 'RRULE':\n              curEvent[fields.recurrenceRule] = value;\n              break;\n\n            default:\n              curEvent[type] = value;\n          }\n        }\n      }\n    });\n    var app = extend([], events, null, true);\n    this.parent.addEvent(this.processOccurrence(app));\n  };\n\n  ICalendarImport.prototype.processOccurrence = function (app) {\n    var appoint = [];\n    var uId = 'UID';\n    var fields = this.parent.eventFields;\n    app.forEach(function (eventObj) {\n      var parentObj;\n      var id;\n\n      if (!eventObj.hasOwnProperty(fields.recurrenceID)) {\n        parentObj = eventObj;\n        id = eventObj[fields.id];\n      }\n\n      var data = new DataManager({\n        json: app\n      }).executeLocal(new Query().where('UID', 'equal', eventObj[uId]));\n\n      if (data.length > 1 && isNullOrUndefined(eventObj[fields.recurrenceID])) {\n        for (var i = 0; i < data.length; i++) {\n          if (data[i].hasOwnProperty(fields.recurrenceID)) {\n            var exdate = data[i][fields.recurrenceID];\n            data[i][fields.recurrenceID] = id;\n            data[i][fields.recurrenceException] = null;\n            parentObj[fields.recurrenceException] = isNullOrUndefined(parentObj[fields.recurrenceException]) ? exdate : parentObj[fields.recurrenceException] + ',' + exdate;\n            appoint.push(data[i]);\n          }\n        }\n\n        appoint.push(parentObj);\n      } else if (!eventObj.hasOwnProperty(fields.recurrenceID)) {\n        appoint.push(eventObj);\n      }\n    });\n    return appoint;\n  };\n\n  ICalendarImport.prototype.getDateString = function (value) {\n    value = value || '';\n    return value.replace(/\\\\\\,/g, ',').replace(/\\\\\\;/g, ';').replace(/\\\\[nN]/g, '\\n').replace(/\\\\\\\\/g, '\\\\');\n  };\n\n  ICalendarImport.prototype.dateParsing = function (element) {\n    var expression = /([^':;]+)((?:;(?:[^':;]+)(?:=(?:(?:'[^']*')|(?:[^':;]+))))*):(.*)/;\n    var split = element.match(expression).slice(1);\n    var value = split[split.length - 1];\n    var newDate = new Date(this.getDateString(value));\n\n    if (element && element.indexOf('VALUE=DATE') > -1) {\n      var data_1 = /^(\\d{4})(\\d{2})(\\d{2})$/.exec(value);\n\n      if (data_1 !== null) {\n        newDate = new Date(parseInt(data_1[1], 10), parseInt(data_1[2], 10) - 1, parseInt(data_1[3], 10));\n      }\n\n      if (element.indexOf('DTSTART') > -1) {\n        this.allDay = true;\n      }\n    }\n\n    var data = /^(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})(Z)?$/.exec(value);\n\n    if (data !== null) {\n      if (data[7] === 'Z') {\n        newDate = new Date(Date.UTC(parseInt(data[1], 10), parseInt(data[2], 10) - 1, parseInt(data[3], 10), parseInt(data[4], 10), parseInt(data[5], 10), parseInt(data[6], 10)));\n      } else {\n        newDate = new Date(parseInt(data[1], 10), parseInt(data[2], 10) - 1, parseInt(data[3], 10), parseInt(data[4], 10), parseInt(data[5], 10), parseInt(data[6], 10));\n      }\n    }\n\n    return newDate;\n  };\n  /**\n   * Get module name.\n   */\n\n\n  ICalendarImport.prototype.getModuleName = function () {\n    return 'iCalendarImport';\n  };\n  /**\n   * To destroy the ICalendarImport.\n   * @return {void}\n   * @private\n   */\n\n\n  ICalendarImport.prototype.destroy = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n  };\n\n  return ICalendarImport;\n}();\n\nexport { ICalendarImport };","map":null,"metadata":{},"sourceType":"module"}