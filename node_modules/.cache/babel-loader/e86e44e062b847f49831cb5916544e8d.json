{"ast":null,"code":"import { addClass, removeClass, Touch, remove, EventHandler, Browser } from '@syncfusion/ej2-base';\nimport { closest, isNullOrUndefined, isBlazor } from '@syncfusion/ej2-base';\nimport * as events from '../base/constant';\nimport * as cls from '../base/css-constant';\nimport * as util from '../base/util';\n/**\n * `touch` module is used to handle touch interactions.\n */\n\nvar ScheduleTouch =\n/** @class */\nfunction () {\n  function ScheduleTouch(parent) {\n    this.parent = parent;\n    this.element = this.parent.element.querySelector('.' + cls.TABLE_CONTAINER_CLASS);\n    this.touchObj = new Touch(this.element, {\n      scroll: this.scrollHandler.bind(this),\n      swipe: this.swipeHandler.bind(this),\n      tapHold: this.tapHoldHandler.bind(this),\n      swipeSettings: {\n        swipeThresholdDistance: 1\n      }\n    });\n    EventHandler.add(this.element, 'transitionend', this.onTransitionEnd, this);\n    this.touchLeftDirection = this.parent.enableRtl ? 'Right' : 'Left';\n    this.touchRightDirection = this.parent.enableRtl ? 'Left' : 'Right';\n  }\n\n  ScheduleTouch.prototype.scrollHandler = function (e) {\n    if (this.parent.currentView === 'Agenda' || this.parent.uiStateValues.action || e.originalEvent && (e.originalEvent.target.classList.contains(cls.APPOINTMENT_CLASS) || closest(e.originalEvent.target, '.' + cls.APPOINTMENT_CLASS))) {\n      return;\n    }\n\n    if (!this.timeStampStart) {\n      this.timeStampStart = Date.now();\n    }\n\n    if (this.element.classList.contains(cls.TRANSLATE_CLASS)) {\n      this.onTransitionEnd();\n    }\n\n    if (e.scrollDirection === 'Left' || e.scrollDirection === 'Right') {\n      var args = {\n        requestType: 'dateNavigate',\n        cancel: false,\n        event: e.originalEvent\n      };\n\n      if (!isBlazor()) {\n        this.parent.trigger(events.actionBegin, args);\n      }\n\n      if (args.cancel) {\n        return;\n      }\n\n      var scrollDiv = this.element.querySelector('.' + cls.CONTENT_WRAP_CLASS);\n\n      if (scrollDiv && scrollDiv.scrollWidth > scrollDiv.clientWidth) {\n        return;\n      } else {\n        this.isScrollTriggered = true;\n        e.originalEvent.preventDefault();\n        e.originalEvent.stopPropagation();\n      }\n    }\n\n    if (e.scrollDirection === this.touchLeftDirection) {\n      if (!this.nextPanel) {\n        this.renderPanel(cls.NEXT_PANEL_CLASS, 'next');\n        this.nextPanel = {\n          element: this.parent.activeView.getPanel(),\n          selectedDate: new Date(this.parent.selectedDate.getTime())\n        };\n        this.setDimensions(this.nextPanel.element);\n      }\n\n      var x = this.parent.enableRtl ? e.distanceX : -e.distanceX;\n      this.element.style.transform = 'translatex(' + (this.getTranslateX(this.element) + x) + 'px)';\n    } else if (e.scrollDirection === this.touchRightDirection) {\n      var prevWidth = 0;\n\n      if (!this.previousPanel) {\n        this.renderPanel(cls.PREVIOUS_PANEL_CLASS, 'previous');\n        this.previousPanel = {\n          element: this.parent.activeView.getPanel(),\n          selectedDate: new Date(this.parent.selectedDate.getTime())\n        };\n        this.setDimensions(this.previousPanel.element);\n        prevWidth = this.previousPanel.element.offsetWidth;\n      }\n\n      var x = this.parent.enableRtl ? prevWidth - e.distanceX : -prevWidth + e.distanceX;\n      this.element.style.transform = 'translatex(' + (this.getTranslateX(this.element) + x) + 'px)';\n    }\n  };\n\n  ScheduleTouch.prototype.swipeHandler = function (e) {\n    if (!this.isScrollTriggered || this.parent.uiStateValues.action) {\n      return;\n    }\n\n    this.isScrollTriggered = false;\n\n    if (e.swipeDirection === 'Left' || e.swipeDirection === 'Right') {\n      var time = Date.now() - this.timeStampStart;\n      var offsetDist = e.distanceX * (Browser.isDevice ? 6 : 1.66);\n\n      if (offsetDist > time || e.distanceX > this.parent.element.offsetWidth / 2) {\n        this.swapPanels(e.swipeDirection);\n\n        if (offsetDist > time && e.distanceX > this.parent.element.offsetWidth / 2) {\n          this.element.style.transitionDuration = offsetDist / time / 10 + 's';\n        }\n\n        this.confirmSwipe(e.swipeDirection);\n      } else {\n        this.cancelSwipe();\n      }\n\n      var args = {\n        requestType: 'dateNavigate',\n        cancel: false,\n        event: e.originalEvent\n      };\n      this.parent.trigger(events.actionComplete, args);\n    } else {\n      this.cancelSwipe();\n    }\n\n    this.timeStampStart = null;\n  };\n\n  ScheduleTouch.prototype.tapHoldHandler = function (e) {\n    var target = closest(e.originalEvent.target, '.' + cls.APPOINTMENT_CLASS);\n\n    if (!isNullOrUndefined(target) && this.parent.isAdaptive) {\n      this.parent.quickPopup.tapHoldEventPopup(e.originalEvent);\n      return;\n    }\n  };\n\n  ScheduleTouch.prototype.renderPanel = function (clsName, nextPrevType) {\n    if (!this.currentPanel) {\n      this.currentPanel = {\n        element: this.parent.activeView.getPanel(),\n        selectedDate: new Date(this.parent.selectedDate.getTime())\n      };\n      this.setDimensions(this.currentPanel.element);\n    } else {\n      this.parent.setProperties({\n        selectedDate: this.currentPanel.selectedDate\n      }, true);\n    }\n\n    this.parent.setProperties({\n      selectedDate: this.parent.activeView.getNextPreviousDate(nextPrevType)\n    }, true);\n    this.parent.activeView.getRenderDates();\n    this.parent.activeView.renderLayout(clsName);\n  };\n\n  ScheduleTouch.prototype.swapPanels = function (direction) {\n    if (direction === this.touchLeftDirection) {\n      var temp = this.nextPanel;\n      this.nextPanel = this.currentPanel;\n      this.currentPanel = temp;\n    } else {\n      var temp = this.previousPanel;\n      this.previousPanel = this.currentPanel;\n      this.currentPanel = temp;\n    }\n  };\n\n  ScheduleTouch.prototype.confirmSwipe = function (swipeDirection) {\n    var _this = this;\n\n    var previousDate = swipeDirection === this.touchLeftDirection ? this.nextPanel.selectedDate : this.previousPanel.selectedDate;\n    var args = {\n      action: 'date',\n      cancel: false,\n      previousDate: previousDate,\n      currentDate: this.currentPanel.selectedDate\n    };\n    this.parent.trigger(events.navigating, args, function (navArgs) {\n      if (navArgs.cancel) {\n        _this.swapPanels(swipeDirection);\n\n        _this.cancelSwipe();\n      } else {\n        _this.parent.activeView.setPanel(_this.currentPanel.element);\n\n        _this.parent.setProperties({\n          selectedDate: _this.currentPanel.selectedDate\n        }, true);\n\n        var translateX = void 0;\n\n        if (_this.parent.enableRtl) {\n          translateX = swipeDirection === _this.touchLeftDirection ? _this.previousPanel ? _this.previousPanel.element.offsetLeft : _this.currentPanel.element.offsetWidth : 0;\n        } else {\n          translateX = swipeDirection === _this.touchLeftDirection ? -_this.currentPanel.element.offsetLeft : 0;\n        }\n\n        addClass([_this.element], cls.TRANSLATE_CLASS);\n        _this.element.style.transform = 'translatex(' + translateX + 'px)';\n\n        if (_this.parent.headerModule) {\n          _this.parent.headerModule.updateDateRange(_this.parent.activeView.getDateRangeText());\n        }\n\n        _this.parent.renderModule.refreshDataManager();\n      }\n    });\n  };\n\n  ScheduleTouch.prototype.cancelSwipe = function () {\n    this.parent.activeView.setPanel(this.currentPanel.element);\n    this.parent.setProperties({\n      selectedDate: this.currentPanel.selectedDate\n    }, true);\n    this.parent.activeView.getRenderDates();\n    this.parent.activeView.generateColumnLevels();\n    addClass([this.element], cls.TRANSLATE_CLASS);\n    var prevWidth = this.previousPanel ? this.previousPanel.element.offsetWidth : 0;\n    this.element.style.transform = 'translatex(' + (this.parent.enableRtl ? prevWidth : -this.currentPanel.element.offsetLeft) + 'px)';\n  };\n\n  ScheduleTouch.prototype.onTransitionEnd = function () {\n    removeClass([this.element], cls.TRANSLATE_CLASS);\n    this.element.style.transitionDuration = '';\n    this.element.style.transform = '';\n\n    if (this.previousPanel) {\n      remove(this.previousPanel.element);\n      this.previousPanel = null;\n      removeClass([this.currentPanel.element], cls.PREVIOUS_PANEL_CLASS);\n      addClass([this.currentPanel.element], cls.CURRENT_PANEL_CLASS);\n    }\n\n    if (this.nextPanel) {\n      remove(this.nextPanel.element);\n      this.nextPanel = null;\n      removeClass([this.currentPanel.element], cls.NEXT_PANEL_CLASS);\n      addClass([this.currentPanel.element], cls.CURRENT_PANEL_CLASS);\n    }\n\n    this.currentPanel = null;\n    this.parent.activeView.getPanel().style.width = '';\n  };\n\n  ScheduleTouch.prototype.getTranslateX = function (element) {\n    var style = window.getComputedStyle(element);\n    return new WebKitCSSMatrix(style.webkitTransform).m41;\n  };\n\n  ScheduleTouch.prototype.setDimensions = function (element) {\n    element.style.width = this.parent.element.clientWidth + 'px';\n  };\n\n  ScheduleTouch.prototype.resetValues = function () {\n    this.currentPanel = null;\n    this.previousPanel = null;\n    this.nextPanel = null;\n    this.timeStampStart = null;\n    this.element.style.transform = '';\n    util.removeChildren(this.element);\n    removeClass([this.element], cls.TRANSLATE_CLASS);\n  };\n  /**\n   * @hidden\n   */\n\n\n  ScheduleTouch.prototype.destroy = function () {\n    this.touchObj.destroy();\n    EventHandler.remove(this.element, 'transitionend', this.onTransitionEnd);\n    this.resetValues();\n  };\n\n  return ScheduleTouch;\n}();\n\nexport { ScheduleTouch };","map":null,"metadata":{},"sourceType":"module"}