{"ast":null,"code":"import { isNullOrUndefined, getDefaultDateObject, getValue, cldrData } from '@syncfusion/ej2-base';\nimport { MS_PER_DAY, addDays, resetTime } from '../schedule/base/util';\nimport { Islamic, Gregorian } from '../common/calendar-util';\nimport { Timezone } from '../schedule/timezone/timezone';\n/**\n * Date Generator from Recurrence Rule\n */\n\nexport function generateSummary(rule, localeObject, locale, calendarType) {\n  if (calendarType === void 0) {\n    calendarType = 'Gregorian';\n  }\n\n  var ruleObject = extractObjectFromRule(rule);\n  var summary = localeObject.getConstant(EVERY) + ' ';\n  var cldrObj;\n  var cldrObj1;\n  var calendarMode = calendarType.toLowerCase();\n\n  if (locale === 'en' || locale === 'en-US') {\n    cldrObj1 = getValue('months.stand-alone.abbreviated', getDefaultDateObject(calendarMode));\n    cldrObj = getValue('days.stand-alone.abbreviated', getDefaultDateObject(calendarMode));\n  } else {\n    cldrObj1 = getValue('main.' + '' + locale + '.dates.calendars.' + calendarMode + '.months.stand-alone.abbreviated', cldrData);\n    cldrObj = getValue('main.' + '' + locale + '.dates.calendars.' + calendarMode + '.days.stand-alone.abbreviated', cldrData);\n  }\n\n  if (ruleObject.interval > 1) {\n    summary += ruleObject.interval + ' ';\n  }\n\n  switch (ruleObject.freq) {\n    case 'DAILY':\n      summary += localeObject.getConstant(DAYS);\n      break;\n\n    case 'WEEKLY':\n      summary += localeObject.getConstant(WEEKS) + ' ' + localeObject.getConstant(ON) + ' ';\n      ruleObject.day.forEach(function (day, index) {\n        summary += getValue(DAYINDEXOBJECT[day], cldrObj);\n        summary += ruleObject.day.length - 1 === index ? '' : ', ';\n      });\n      break;\n\n    case 'MONTHLY':\n      summary += localeObject.getConstant(MONTHS) + ' ' + localeObject.getConstant(ON) + ' ';\n      summary += getMonthSummary(ruleObject, cldrObj, localeObject);\n      break;\n\n    case 'YEARLY':\n      summary += localeObject.getConstant(YEARS) + ' ' + localeObject.getConstant(ON) + ' ';\n      summary += getValue(ruleObject.month[0].toString(), cldrObj1) + ' ';\n      summary += getMonthSummary(ruleObject, cldrObj, localeObject);\n      break;\n  }\n\n  if (ruleObject.count) {\n    summary += ', ' + ruleObject.count + ' ' + localeObject.getConstant(TIMES);\n  } else if (ruleObject.until) {\n    var tempDate = ruleObject.until;\n    summary += ', ' + localeObject.getConstant(UNTIL) + ' ' + tempDate.getDate() + ' ' + getValue((tempDate.getMonth() + 1).toString(), cldrObj1) + ' ' + tempDate.getFullYear();\n  }\n\n  return summary;\n}\n\nfunction getMonthSummary(ruleObject, cldrObj, localeObj) {\n  var summary = '';\n\n  if (ruleObject.monthDay.length) {\n    summary += ruleObject.monthDay[0];\n  } else if (ruleObject.day) {\n    var pos = ruleObject.setPosition - 1;\n    summary += localeObj.getConstant(WEEKPOS[pos > -1 ? pos : WEEKPOS.length - 1]) + ' ' + getValue(DAYINDEXOBJECT[ruleObject.day[0]], cldrObj);\n  }\n\n  return summary;\n}\n\nexport function generate(startDate, rule, excludeDate, startDayOfWeek, maximumCount, viewDate, calendarMode, oldTimezone, newTimezone) {\n  if (maximumCount === void 0) {\n    maximumCount = MAXOCCURRENCE;\n  }\n\n  if (viewDate === void 0) {\n    viewDate = null;\n  }\n\n  if (calendarMode === void 0) {\n    calendarMode = 'Gregorian';\n  }\n\n  if (oldTimezone === void 0) {\n    oldTimezone = null;\n  }\n\n  if (newTimezone === void 0) {\n    newTimezone = null;\n  }\n\n  var ruleObject = extractObjectFromRule(rule);\n  var cacheDate;\n  calendarUtil = getCalendarUtil(calendarMode);\n  var data = [];\n  var modifiedDate = new Date(startDate.getTime());\n  tempExcludeDate = [];\n  var tempDate = isNullOrUndefined(excludeDate) ? [] : excludeDate.split(',');\n  var tz = new Timezone();\n  tempDate.forEach(function (content) {\n    var parsedDate = getDateFromRecurrenceDateString(content);\n\n    if (oldTimezone && newTimezone) {\n      parsedDate = tz.convert(new Date(parsedDate.getTime()), oldTimezone, newTimezone);\n    }\n\n    tempExcludeDate.push(new Date(parsedDate.getTime()).setHours(0, 0, 0, 0));\n  });\n  ruleObject.recExceptionCount = !isNullOrUndefined(ruleObject.count) ? tempExcludeDate.length : 0;\n\n  if (viewDate && viewDate > startDate && !ruleObject.count) {\n    tempViewDate = new Date(new Date(viewDate.getTime()).setHours(0, 0, 0));\n  } else {\n    tempViewDate = null;\n  }\n\n  if (!ruleObject.until && tempViewDate) {\n    cacheDate = new Date(tempViewDate.getTime());\n    cacheDate.setDate(tempViewDate.getDate() + maximumCount * ruleObject.interval);\n    ruleObject.until = cacheDate;\n  }\n\n  if (ruleObject.until && startDate > ruleObject.until) {\n    return data;\n  }\n\n  maxOccurrence = maximumCount;\n  setFirstDayOfWeek(DAYINDEX[startDayOfWeek]);\n\n  switch (ruleObject.freq) {\n    case 'DAILY':\n      dailyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n\n    case 'WEEKLY':\n      weeklyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n\n    case 'MONTHLY':\n      monthlyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n\n    case 'YEARLY':\n      yearlyType(modifiedDate, ruleObject.until, data, ruleObject);\n  }\n\n  return data;\n}\nexport function getDateFromRecurrenceDateString(recDateString) {\n  return new Date(recDateString.substr(0, 4) + '-' + recDateString.substr(4, 2) + '-' + recDateString.substr(6, 5) + ':' + recDateString.substr(11, 2) + ':' + recDateString.substr(13));\n}\n\nfunction excludeDateHandler(data, date) {\n  var zeroIndex = new Date(date).setHours(0, 0, 0, 0);\n\n  if (tempExcludeDate.indexOf(zeroIndex) === -1 && (!tempViewDate || zeroIndex >= tempViewDate.getTime())) {\n    data.push(date);\n  }\n}\n\nfunction getDateCount(startDate, ruleObject) {\n  var count = maxOccurrence;\n\n  if (ruleObject.count) {\n    count = ruleObject.count;\n  } else if (ruleObject.until) {\n    if (ruleObject.freq === 'DAILY' || ruleObject.freq === 'WEEKLY') {\n      count = Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1;\n    } else if (ruleObject.freq === 'MONTHLY' || ruleObject.freq === 'YEARLY') {\n      count = Math.floor((ruleObject.until.getMonth() + 12 * ruleObject.until.getFullYear() - (startDate.getMonth() + 12 * startDate.getFullYear())) / ruleObject.interval) + (ruleObject.day.length > 1 ? Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1 : 1);\n\n      if (ruleObject.freq === 'YEARLY') {\n        count = ruleObject.month.length > 1 ? count * ruleObject.month.length : count;\n      }\n    }\n  }\n\n  return count;\n}\n\nfunction dailyType(startDate, endDate, data, ruleObject) {\n  var tempDate = new Date(startDate.getTime());\n  var interval = ruleObject.interval;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var state;\n  var expectedDays = ruleObject.day;\n\n  while (compareDates(tempDate, endDate)) {\n    state = true;\n    state = validateRules(tempDate, ruleObject);\n\n    if (state && (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1 || expectedDays.length === 0)) {\n      excludeDateHandler(data, tempDate.getTime());\n\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n    }\n\n    tempDate.setDate(tempDate.getDate() + interval);\n  }\n}\n\nfunction weeklyType(startDate, endDate, data, ruleObject) {\n  var tempDate = new Date(startDate.getTime());\n\n  if (!ruleObject.day.length) {\n    ruleObject.day.push(DAYINDEX[startDate.getDay()]);\n  }\n\n  var interval = ruleObject.interval;\n  var expectedDays = ruleObject.day;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var weekState = true;\n  var wkstIndex;\n  var weekCollection = [];\n\n  if (expectedDays.length > 1) {\n    if (isNullOrUndefined(ruleObject.wkst) || ruleObject.wkst === '') {\n      ruleObject.wkst = dayIndex[0];\n    }\n\n    wkstIndex = DAYINDEX.indexOf(ruleObject.wkst);\n\n    while (compareDates(tempDate, endDate)) {\n      var startDateDiff = DAYINDEX.indexOf(DAYINDEX[tempDate.getDay()]) - wkstIndex;\n      startDateDiff = startDateDiff === -1 ? 6 : startDateDiff;\n      var weekstartDate = addDays(tempDate, -startDateDiff);\n      var weekendDate = addDays(weekstartDate, 6);\n      var compareTempDate = new Date(tempDate.getTime());\n      resetTime(weekendDate);\n      resetTime(compareTempDate);\n\n      while (weekendDate >= compareTempDate) {\n        if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          weekCollection.push([tempDate.getTime()]);\n        }\n\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          break;\n        }\n\n        tempDate.setDate(tempDate.getDate() + 1);\n        compareTempDate = new Date(tempDate.getTime());\n        resetTime(compareTempDate);\n      }\n\n      tempDate.setDate(tempDate.getDate() - 1);\n\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n\n      tempDate.setDate(tempDate.getDate() + 1 + (interval - 1) * 7);\n      insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\n      weekCollection = [];\n    }\n  } else {\n    tempDate = getStartDateForWeek(startDate, ruleObject.day);\n\n    while (compareDates(tempDate, endDate)) {\n      weekState = validateRules(tempDate, ruleObject);\n\n      if (weekState && expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n        excludeDateHandler(data, tempDate.getTime());\n      }\n\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n\n      tempDate.setDate(tempDate.getDate() + interval * 7);\n    }\n\n    insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\n    weekCollection = [];\n  }\n}\n\nfunction monthlyType(startDate, endDate, data, ruleObject) {\n  // Set monthday value if BYDAY, BYMONTH and Month day property is not set based on start date\n  if (!ruleObject.month.length && !ruleObject.day.length && !ruleObject.monthDay.length) {\n    ruleObject.monthDay.push(startDate.getDate());\n\n    if (ruleObject.freq === 'YEARLY') {\n      ruleObject.month.push(startDate.getMonth() + 1);\n    }\n  } else if (ruleObject.month.length > 0 && !ruleObject.day.length && !ruleObject.monthDay.length) {\n    ruleObject.monthDay.push(startDate.getDate());\n  }\n\n  var ruleType = validateMonthlyRuleType(ruleObject);\n\n  switch (ruleType) {\n    case 'day':\n      switch (ruleObject.freq) {\n        case 'MONTHLY':\n          monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n          break;\n\n        case 'YEARLY':\n          monthlyDayTypeProcess(startDate, endDate, data, ruleObject);\n          break;\n      }\n\n      break;\n\n    case 'both':\n    case 'date':\n      switch (ruleObject.freq) {\n        case 'MONTHLY':\n          monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n          break;\n\n        case 'YEARLY':\n          monthlyDateTypeProcess(startDate, endDate, data, ruleObject);\n          break;\n      }\n\n  }\n}\n\nfunction yearlyType(startDate, endDate, data, ruleObject) {\n  var typeValue = checkYearlyType(ruleObject);\n\n  switch (typeValue) {\n    case 'MONTH':\n      monthlyType(startDate, endDate, data, ruleObject);\n      break;\n\n    case 'WEEKNO':\n      processWeekNo(startDate, endDate, data, ruleObject);\n      break;\n\n    case 'YEARDAY':\n      processYearDay(startDate, endDate, data, ruleObject);\n      break;\n  }\n}\n\nfunction processWeekNo(startDate, endDate, data, ruleObject) {\n  var stDate = calendarUtil.getYearLastDate(startDate, 0);\n  var tempDate;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var state;\n  var startDay;\n  var firstWeekSpan;\n  var weekNos = ruleObject.weekNo;\n  var weekNo;\n  var maxDate;\n  var minDate;\n  var weekCollection = [];\n  var expectedDays = ruleObject.day;\n\n  while (compareDates(stDate, endDate)) {\n    startDay = dayIndex.indexOf(DAYINDEX[stDate.getDay()]);\n    firstWeekSpan = 6 - startDay + 1;\n\n    for (var index = 0; index < weekNos.length; index++) {\n      weekNo = weekNos[index];\n      weekNo = weekNo > 0 ? weekNo : 53 + weekNo + 1;\n      maxDate = weekNo === 1 ? firstWeekSpan : firstWeekSpan + (weekNo - 1) * 7;\n      minDate = weekNo === 1 ? firstWeekSpan - 7 : firstWeekSpan + (weekNo - 2) * 7;\n\n      while (minDate < maxDate) {\n        tempDate = new Date(stDate.getTime() + MS_PER_DAY * minDate);\n\n        if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          if (isNullOrUndefined(ruleObject.setPosition)) {\n            insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\n          } else {\n            weekCollection.push([tempDate.getTime()]);\n          }\n        }\n\n        minDate++;\n      }\n    }\n\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(weekCollection, state, startDate, endDate, data, ruleObject);\n    }\n\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n\n    stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\n    weekCollection = [];\n  }\n}\n\nfunction processYearDay(startDate, endDate, data, ruleObject) {\n  var stDate = calendarUtil.getYearLastDate(startDate, 0);\n  var tempDate;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var state;\n  var dateCollection = [];\n  var date;\n  var expectedDays = ruleObject.day;\n\n  while (compareDates(stDate, endDate)) {\n    for (var index = 0; index < ruleObject.yearDay.length; index++) {\n      date = ruleObject.yearDay[index];\n      tempDate = new Date(stDate.getTime());\n\n      if ((date === calendarUtil.getLeapYearDaysCount() || date === -calendarUtil.getLeapYearDaysCount()) && !calendarUtil.isLeapYear(calendarUtil.getFullYear(tempDate), 1)) {\n        tempDate.setDate(tempDate.getDate() + 1);\n        continue;\n      }\n\n      tempDate.setDate(tempDate.getDate() + (date < 0 ? calendarUtil.getYearDaysCount(tempDate, 1) + 1 + date : date));\n\n      if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n        if (ruleObject.setPosition == null) {\n          insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\n        } else {\n          dateCollection.push([tempDate.getTime()]);\n        }\n      }\n    }\n\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject);\n    }\n\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n\n    stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\n    dateCollection = [];\n  }\n}\n\nfunction checkYearlyType(ruleObject) {\n  if (ruleObject.yearDay.length) {\n    return 'YEARDAY';\n  } else if (ruleObject.weekNo.length) {\n    return 'WEEKNO';\n  }\n\n  return 'MONTH';\n}\n\nfunction initializeRecRuleVariables(startDate, ruleObject) {\n  var ruleData = {\n    monthCollection: [],\n    index: 0,\n    tempDate: new Date(startDate.getTime()),\n    mainDate: new Date(startDate.getTime()),\n    expectedCount: getDateCount(startDate, ruleObject),\n    monthInit: 0,\n    dateCollection: []\n  };\n\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(ruleData.tempDate, ruleObject.month[0], ruleData.tempDate.getDate());\n  }\n\n  return ruleData;\n}\n\nfunction monthlyDateTypeProcess(startDate, endDate, data, ruleObject) {\n  if (ruleObject.month.length) {\n    monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n    return;\n  }\n\n  var ruleData = initializeRecRuleVariables(startDate, ruleObject);\n  var currentMonthDate;\n  ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\n\n  while (compareDates(ruleData.tempDate, endDate)) {\n    currentMonthDate = new Date(ruleData.tempDate.getTime());\n\n    while (calendarUtil.isSameYear(currentMonthDate, ruleData.tempDate) && ruleData.expectedCount && data.length + ruleObject.recExceptionCount <= ruleData.expectedCount) {\n      if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && !calendarUtil.checkMonth(ruleData.tempDate, ruleObject.month)) {\n        processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, false);\n        ruleData.beginDate = new Date(ruleData.tempDate.getTime());\n        ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n      } else {\n        calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\n        ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n        break;\n      }\n    }\n\n    ruleData.tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());\n    insertDataCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\n\n    if (calendarUtil.isLastMonth(ruleData.tempDate)) {\n      calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\n      ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n    }\n\n    if (ruleData.expectedCount && data.length + ruleObject.recExceptionCount >= ruleData.expectedCount) {\n      return;\n    }\n\n    ruleData.tempDate.setFullYear(ruleData.tempDate.getFullYear() + ruleObject.interval - 1);\n    ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n    ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n    ruleData.dateCollection = [];\n  }\n}\n\nfunction monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\n  var ruleData = initializeRecRuleVariables(startDate, ruleObject);\n  ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\n\n  while (compareDates(ruleData.tempDate, endDate)) {\n    ruleData.beginDate = new Date(ruleData.tempDate.getTime());\n    processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, true, startDate, data);\n\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\n    }\n\n    if (ruleData.expectedCount && data.length + ruleObject.recExceptionCount >= ruleData.expectedCount) {\n      return;\n    }\n\n    ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n    ruleData.dateCollection = [];\n  }\n} // To process date collection for Monthly & Yearly based on BYMONTH Day property\n\n\nfunction processDateCollectionForByMonthDay(ruleObject, recRuleVariables, endDate, isByMonth, startDate, data) {\n  for (var index = 0; index < ruleObject.monthDay.length; index++) {\n    recRuleVariables.date = ruleObject.monthDay[index];\n    recRuleVariables.tempDate = calendarUtil.getMonthStartDate(recRuleVariables.tempDate);\n    var maxDate = calendarUtil.getMonthDaysCount(recRuleVariables.tempDate);\n    recRuleVariables.date = recRuleVariables.date > 0 ? recRuleVariables.date : maxDate + recRuleVariables.date + 1;\n\n    if (validateProperDate(recRuleVariables.tempDate, recRuleVariables.date, recRuleVariables.mainDate) && recRuleVariables.date > 0) {\n      calendarUtil.setDate(recRuleVariables.tempDate, recRuleVariables.date);\n\n      if (endDate && recRuleVariables.tempDate > endDate) {\n        return;\n      }\n\n      if (ruleObject.day.length === 0 || ruleObject.day.indexOf(DAYINDEX[recRuleVariables.tempDate.getDay()]) > -1) {\n        if (isByMonth && isNullOrUndefined(ruleObject.setPosition) && recRuleVariables.expectedCount && data.length + ruleObject.recExceptionCount < recRuleVariables.expectedCount) {\n          insertDateCollection(recRuleVariables.state, startDate, endDate, data, ruleObject, recRuleVariables.tempDate.getTime());\n        } else {\n          recRuleVariables.dateCollection.push([recRuleVariables.tempDate.getTime()]);\n        }\n      }\n    }\n  }\n}\n\nfunction setNextValidDate(tempDate, ruleObject, monthInit, beginDate, interval) {\n  if (beginDate === void 0) {\n    beginDate = null;\n  }\n\n  var monthData = beginDate ? beginDate.getMonth() : 0;\n  var startDate = calendarUtil.getMonthStartDate(tempDate);\n  interval = isNullOrUndefined(interval) ? ruleObject.interval : interval;\n  tempDate.setFullYear(startDate.getFullYear());\n  tempDate.setMonth(startDate.getMonth());\n  tempDate.setDate(startDate.getDate());\n\n  if (ruleObject.month.length) {\n    monthInit++;\n    monthInit = monthInit % ruleObject.month.length;\n    calendarUtil.setMonth(tempDate, ruleObject.month[monthInit], 1);\n\n    if (monthInit === 0) {\n      calendarUtil.addYears(tempDate, interval, ruleObject.month[0]);\n    }\n  } else {\n    if (beginDate && beginDate.getFullYear() < tempDate.getFullYear()) {\n      monthData = tempDate.getMonth() - 1;\n    }\n\n    calendarUtil.setValidDate(tempDate, interval, 1, monthData, beginDate);\n  }\n\n  return monthInit;\n} // To get month collection when BYDAY property having more than one value in list.\n\n\nfunction getMonthCollection(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var tempDate = new Date(startDate.getTime());\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  var monthCollection = [];\n  var dateCollection = [];\n  var dates = [];\n  var index;\n  var state;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var monthInit = 0;\n  var beginDate;\n\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n\n  while (compareDates(tempDate, endDate) && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    var currentMonthDate = new Date(tempDate.getTime());\n    var isHavingNumber = expectedDays.map(function (item) {\n      return HASNUMBER.test(item);\n    });\n\n    if (isHavingNumber.indexOf(true) > -1) {\n      for (var j = 0; j <= expectedDays.length - 1; j++) {\n        var expectedDaysArray = expectedDays[j].match(SPLITNUMBERANDSTRING);\n        var position = parseInt(expectedDaysArray[0], 10);\n        tempDate = new Date(tempDate.getTime());\n        tempDate = calendarUtil.getMonthStartDate(tempDate);\n        tempDate = getStartDateForWeek(tempDate, expectedDays);\n        currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\n\n        while (calendarUtil.isSameYear(currentMonthDate, tempDate) && calendarUtil.isSameMonth(currentMonthDate, tempDate)) {\n          if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentMonthDate.getDay()]) {\n            monthCollection.push([currentMonthDate.getTime()]);\n          }\n\n          currentMonthDate.setDate(currentMonthDate.getDate() + 1);\n        }\n\n        currentMonthDate.setDate(currentMonthDate.getDate() - 1);\n\n        if (expectedDaysArray[0].indexOf('-') > -1) {\n          index = monthCollection.length - -1 * position;\n        } else {\n          index = position - 1;\n        }\n\n        index = isNaN(index) ? 0 : index;\n\n        if (monthCollection.length > 0) {\n          isNullOrUndefined(ruleObject.setPosition) ? insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index) : dateCollection = [filterDateCollectionByIndex(monthCollection, index, dates)];\n        }\n\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          return;\n        }\n\n        monthCollection = [];\n      }\n\n      if (!isNullOrUndefined(ruleObject.setPosition)) {\n        insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n        dates = [];\n      }\n\n      monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n      monthCollection = [];\n    } else {\n      var weekCollection = [];\n      var dayCycleData = processWeekDays(expectedDays);\n      currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\n      var initialDate = new Date(tempDate.getTime());\n      beginDate = new Date(tempDate.getTime());\n\n      while (calendarUtil.isSameMonth(initialDate, tempDate)) {\n        weekCollection.push(tempDate.getTime());\n\n        if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          monthCollection.push(weekCollection);\n          weekCollection = [];\n        }\n\n        tempDate.setDate(tempDate.getDate() + dayCycleData[DAYINDEX[tempDate.getDay()]]);\n      }\n\n      index = ruleObject.setPosition < 1 ? monthCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n\n      if (isNullOrUndefined(ruleObject.setPosition)) {\n        index = 0;\n        var datas = [];\n\n        for (var week = 0; week < monthCollection.length; week++) {\n          for (var row = 0; row < monthCollection[week].length; row++) {\n            datas.push(monthCollection[week][row]);\n          }\n        }\n\n        monthCollection = [datas];\n      }\n\n      if (monthCollection.length > 0) {\n        insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n      }\n\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        return;\n      }\n\n      monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n      monthCollection = [];\n    }\n  }\n} // To process monday day type for FREQ=MONTHLY\n\n\nfunction monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day; // When BYDAY property having more than 1 value.\n\n  if (expectedDays.length > 1) {\n    getMonthCollection(startDate, endDate, data, ruleObject);\n    return;\n  }\n\n  var tempDate = new Date(startDate.getTime());\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var monthCollection = [];\n  var beginDate;\n  var monthInit = 0;\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n\n  while (compareDates(tempDate, endDate) && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    beginDate = new Date(tempDate.getTime());\n    var currentMonthDate = new Date(tempDate.getTime());\n\n    while (calendarUtil.isSameMonth(tempDate, currentMonthDate)) {\n      monthCollection.push([currentMonthDate.getTime()]);\n      currentMonthDate.setDate(currentMonthDate.getDate() + 7);\n    } // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\n\n\n    insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\n    monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    monthCollection = [];\n  }\n} // To process monday day type for FREQ=YEARLY\n\n\nfunction monthlyDayTypeProcess(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var isHavingNumber = expectedDays.map(function (item) {\n    return HASNUMBER.test(item);\n  }); // If BYDAY property having more than 1 value in list\n\n  if (expectedDays.length > 1 && isHavingNumber.indexOf(true) > -1) {\n    processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject);\n    return;\n  } else if (ruleObject.month.length && expectedDays.length === 1 && isHavingNumber.indexOf(true) > -1) {\n    monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n    return;\n  }\n\n  var tempDate = new Date(startDate.getTime());\n  var currentMonthDate;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var interval = ruleObject.interval;\n  var monthCollection = [];\n\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\n  } // Set the date as start date of the yeear if yearly freq having ByDay property alone\n\n\n  if (isNullOrUndefined(ruleObject.setPosition) && ruleObject.month.length === 0 && ruleObject.weekNo.length === 0) {\n    tempDate.setFullYear(startDate.getFullYear(), 0, 1);\n  }\n\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n\n  while (compareDates(tempDate, endDate)) {\n    currentMonthDate = new Date(tempDate.getTime());\n\n    while (calendarUtil.isSameYear(currentMonthDate, tempDate) && expectedCount && data.length + ruleObject.recExceptionCount <= expectedCount) {\n      currentMonthDate = new Date(tempDate.getTime());\n\n      while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\n        if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && !calendarUtil.checkMonth(tempDate, ruleObject.month)) {\n          if (expectedDays.length > 1) {\n            if (calendarUtil.compareMonth(currentMonthDate, tempDate)) {\n              calendarUtil.setValidDate(tempDate, 1, 1);\n              tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n              break;\n            }\n\n            if (expectedDays.indexOf(DAYINDEX[currentMonthDate.getDay()]) > -1) {\n              monthCollection.push([currentMonthDate.getTime()]);\n            }\n\n            currentMonthDate.setDate(currentMonthDate.getDate() + 1);\n          } else {\n            // If BYDAY property having 1 value in list\n            if (currentMonthDate.getFullYear() > tempDate.getFullYear()) {\n              calendarUtil.setValidDate(tempDate, 1, 1);\n              tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n              break;\n            }\n\n            var newstr = getDayString(expectedDays[0]);\n\n            if (DAYINDEX[currentMonthDate.getDay()] === newstr && new Date(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), 0) > new Date(startDate.getFullYear())) {\n              monthCollection.push([currentMonthDate.getTime()]);\n            }\n\n            currentMonthDate.setDate(currentMonthDate.getDate() + 7);\n          }\n        } else {\n          calendarUtil.setValidDate(tempDate, 1, 1);\n          tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n          break;\n        }\n      }\n    }\n\n    tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate()); // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\n\n    insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\n\n    if (calendarUtil.isLastMonth(tempDate)) {\n      calendarUtil.setValidDate(tempDate, 1, 1);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    }\n\n    tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\n\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    monthCollection = [];\n  }\n} // To process the recurrence rule when BYDAY property having values with integer\n\n\nfunction processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var tempDate = new Date(startDate.getTime());\n  var interval = ruleObject.interval;\n  var monthCollection = [];\n  var dateCollection = [];\n  var index;\n  var state;\n  var monthInit = 0;\n  var currentMonthDate;\n  var currentDate;\n  var beginDate;\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  var datas = [];\n\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n\n  while (compareDates(tempDate, endDate)) {\n    currentMonthDate = new Date(tempDate.getTime());\n\n    for (var i = 0; i <= ruleObject.month.length; i++) {\n      for (var j = 0; j <= expectedDays.length - 1; j++) {\n        tempDate = calendarUtil.getMonthStartDate(tempDate);\n        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n        monthCollection = [];\n\n        while (calendarUtil.isSameYear(currentMonthDate, tempDate) && expectedCount && data.length + ruleObject.recExceptionCount <= expectedCount) {\n          while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\n            currentMonthDate = new Date(tempDate.getTime());\n\n            if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && ruleObject.month[i] === calendarUtil.getMonth(currentMonthDate)) {\n              var expectedDaysArray = expectedDays[j].match(SPLITNUMBERANDSTRING);\n              var position = parseInt(expectedDaysArray[0], 10);\n              currentDate = new Date(tempDate.getTime());\n\n              while (calendarUtil.isSameYear(currentDate, tempDate) && calendarUtil.isSameMonth(currentDate, tempDate)) {\n                if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentDate.getDay()]) {\n                  monthCollection.push([currentDate.getTime()]);\n                }\n\n                currentDate.setDate(currentDate.getDate() + 1);\n              }\n\n              currentDate.setDate(currentDate.getDate() - 1);\n\n              if (expectedDaysArray[0].indexOf('-') > -1) {\n                index = monthCollection.length - -1 * position;\n              } else {\n                index = position - 1;\n              }\n\n              index = isNaN(index) ? 0 : index;\n            }\n\n            monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate, 1);\n            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n          }\n        }\n\n        tempDate = j === 0 && currentDate ? new Date(currentDate.getTime()) : new Date(currentMonthDate.getTime());\n\n        if (monthCollection.length > 0) {\n          isNullOrUndefined(ruleObject.setPosition) ? insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index) : dateCollection = [filterDateCollectionByIndex(monthCollection, index, datas)];\n        }\n\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          return;\n        }\n      }\n    }\n\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n      datas = [];\n    }\n\n    if (calendarUtil.isLastMonth(tempDate)) {\n      calendarUtil.setValidDate(tempDate, 1, 1);\n      tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\n    } else {\n      tempDate.setFullYear(tempDate.getFullYear() + interval);\n    }\n\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n\n    if (ruleObject.month.length) {\n      calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\n    }\n  }\n} // To get recurrence collection if BYSETPOS is null\n\n\nfunction getRecurrenceCollection(monthCollection, expectedDays) {\n  var index;\n  var recurrenceCollectionObject = {\n    monthCollection: [],\n    index: 0\n  };\n\n  if (expectedDays.length === 1) {\n    // To split numeric value from BYDAY property value\n    var expectedDaysArrays = expectedDays[0].match(SPLITNUMBERANDSTRING);\n    var arrPosition = void 0;\n\n    if (expectedDaysArrays.length > 1) {\n      arrPosition = parseInt(expectedDaysArrays[0], 10);\n      index = arrPosition < 1 ? monthCollection.length + arrPosition : arrPosition - 1;\n    } else {\n      index = 0;\n      monthCollection = getDateCollectionforBySetPosNull(monthCollection);\n    }\n  } else {\n    index = 0;\n    monthCollection = getDateCollectionforBySetPosNull(monthCollection);\n  }\n\n  recurrenceCollectionObject.monthCollection = monthCollection;\n  recurrenceCollectionObject.index = index;\n  return recurrenceCollectionObject;\n}\n\nfunction insertDataCollection(dateCollection, state, startDate, endDate, data, ruleObject) {\n  var index = ruleObject.setPosition < 1 ? dateCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n\n  if (isNullOrUndefined(ruleObject.setPosition)) {\n    index = 0;\n    dateCollection = getDateCollectionforBySetPosNull(dateCollection);\n  }\n\n  if (dateCollection.length > 0) {\n    insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject, index);\n  }\n} // To process month collection if BYSETPOS is null\n\n\nfunction getDateCollectionforBySetPosNull(monthCollection) {\n  var datas = [];\n\n  for (var week = 0; week < monthCollection.length; week++) {\n    for (var row = 0; row < monthCollection[week].length; row++) {\n      datas.push(new Date(monthCollection[week][row]).getTime());\n    }\n  }\n\n  monthCollection = datas.length > 0 ? [datas] : [];\n  return monthCollection;\n} // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\n\n\nfunction insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var index;\n  var state;\n  var datas = [];\n  var dateCollection = [];\n  var recurrenceCollections;\n  recurrenceCollections = getRecurrenceCollection(monthCollection, expectedDays);\n  monthCollection = recurrenceCollections.monthCollection;\n  index = recurrenceCollections.index;\n\n  if (ruleObject.setPosition != null) {\n    dateCollection = [filterDateCollectionByIndex(monthCollection, index, datas)];\n    insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n  } else {\n    if (monthCollection.length > 0) {\n      insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n    }\n  }\n\n  datas = [];\n} // To filter date collection when BYDAY property having values with number\n\n\nfunction filterDateCollectionByIndex(monthCollection, index, datas) {\n  for (var week = 0; week < monthCollection[index].length; week++) {\n    datas.push(monthCollection[index][week]);\n  }\n\n  return datas;\n} // To insert processed date collection in final array element\n\n\nfunction insertDateCollection(state, startDate, endDate, data, ruleObject, dayData) {\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var chDate = new Date(dayData);\n  state = validateRules(chDate, ruleObject);\n\n  if (chDate >= startDate && compareDates(chDate, endDate) && state && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    excludeDateHandler(data, dayData);\n  }\n} // To process datte collection based on Byset position after process the collection based on BYDAY property value index: EX:BYDAY=1SUm-1SU\n\n\nfunction insertDateCollectionBasedonBySetPos(monthCollection, state, startDate, endDate, data, ruleObject) {\n  if (monthCollection.length > 0) {\n    for (var week = 0; week < monthCollection.length; week++) {\n      monthCollection[week].sort();\n      var index = ruleObject.setPosition < 1 ? monthCollection[week].length + ruleObject.setPosition : ruleObject.setPosition - 1;\n      var dayData = monthCollection[week][index];\n      insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\n    }\n  }\n} // To insert datas into existing collection which is processed from previous loop.\n\n\nfunction insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index) {\n  if (monthCollection.length > 0) {\n    index = !isNullOrUndefined(index) ? index : ruleObject.setPosition < 1 ? monthCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n    monthCollection[index].sort();\n\n    for (var week = 0; week < monthCollection[index].length; week++) {\n      var dayData = monthCollection[index][week];\n      insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\n    }\n  }\n}\n\nfunction compareDates(startDate, endDate) {\n  return endDate ? startDate <= endDate : true;\n}\n\nfunction getDayString(expectedDays) {\n  // To get BYDAY value without numeric value\n  var newstr = expectedDays.replace(REMOVENUMBERINSTRING, '');\n  return newstr;\n}\n\nfunction checkDayIndex(day, expectedDays) {\n  var sortedExpectedDays = [];\n  expectedDays.forEach(function (element) {\n    var expectedDaysNumberSplit = element.match(SPLITNUMBERANDSTRING);\n\n    if (expectedDaysNumberSplit.length === 2) {\n      sortedExpectedDays.push(expectedDaysNumberSplit[1]);\n    } else {\n      sortedExpectedDays.push(expectedDaysNumberSplit[0]);\n    }\n  });\n  return sortedExpectedDays.indexOf(DAYINDEX[day]) === -1;\n}\n\nfunction getStartDateForWeek(startDate, expectedDays) {\n  var tempDate = new Date(startDate.getTime());\n  var newstr;\n\n  if (expectedDays.length > 0) {\n    var expectedDaysArr = [];\n\n    for (var i = 0; i <= expectedDays.length - 1; i++) {\n      newstr = getDayString(expectedDays[i]);\n      expectedDaysArr.push(newstr);\n    }\n\n    if (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1) {\n      do {\n        tempDate.setDate(tempDate.getDate() + 1);\n      } while (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1);\n    }\n  }\n\n  return tempDate;\n}\n\nexport function extractObjectFromRule(rules) {\n  var ruleObject = {\n    freq: null,\n    interval: 1,\n    count: null,\n    until: null,\n    day: [],\n    wkst: null,\n    month: [],\n    weekNo: [],\n    monthDay: [],\n    yearDay: [],\n    setPosition: null,\n    validRules: []\n  };\n  var rulesList = rules.split(';');\n  var splitData = [];\n  var temp;\n  rulesList.forEach(function (data) {\n    splitData = data.split('=');\n\n    switch (splitData[0]) {\n      case 'UNTIL':\n        temp = splitData[1];\n        ruleObject.until = getDateFromRecurrenceDateString(temp);\n        break;\n\n      case 'BYDAY':\n        ruleObject.day = splitData[1].split(',');\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYMONTHDAY':\n        ruleObject.monthDay = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYMONTH':\n        ruleObject.month = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYYEARDAY':\n        ruleObject.yearDay = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYWEEKNO':\n        ruleObject.weekNo = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'INTERVAL':\n        ruleObject.interval = parseInt(splitData[1], 10);\n        break;\n\n      case 'COUNT':\n        ruleObject.count = parseInt(splitData[1], 10);\n        break;\n\n      case 'BYSETPOS':\n        ruleObject.setPosition = parseInt(splitData[1], 10) > 4 ? -1 : parseInt(splitData[1], 10);\n        break;\n\n      case 'FREQ':\n        ruleObject.freq = splitData[1];\n        break;\n\n      case 'WKST':\n        ruleObject.wkst = splitData[1];\n        break;\n    }\n  });\n\n  if (ruleObject.freq === 'MONTHLY' && ruleObject.monthDay.length === 0) {\n    var index = ruleObject.validRules.indexOf('BYDAY');\n    ruleObject.validRules.splice(index, 1);\n  }\n\n  return ruleObject;\n}\n\nfunction validateProperDate(tempDate, data, startDate) {\n  var maxDate = calendarUtil.getMonthDaysCount(tempDate);\n  return data <= maxDate && tempDate >= startDate;\n}\n\nfunction processWeekDays(expectedDays) {\n  var dayCycle = {};\n  expectedDays.forEach(function (element, index) {\n    if (index === expectedDays.length - 1) {\n      var startIndex = dayIndex.indexOf(element);\n      var temp = startIndex;\n\n      while (temp % 7 !== dayIndex.indexOf(expectedDays[0])) {\n        temp++;\n      }\n\n      dayCycle[element] = temp - startIndex;\n    } else {\n      dayCycle[element] = dayIndex.indexOf(expectedDays[index + 1]) - dayIndex.indexOf(element);\n    }\n  });\n  return dayCycle;\n}\n\nfunction checkDate(tempDate, expectedDate) {\n  var temp = expectedDate.slice(0);\n  var data;\n  var maxDate = calendarUtil.getMonthDaysCount(tempDate);\n  data = temp.shift();\n\n  while (data) {\n    if (data < 0) {\n      data = data + maxDate + 1;\n    }\n\n    if (data === tempDate.getDate()) {\n      return false;\n    }\n\n    data = temp.shift();\n  }\n\n  return true;\n}\n\nfunction checkYear(tempDate, expectedyearDay) {\n  var temp = expectedyearDay.slice(0);\n  var data;\n  var yearDay = getYearDay(tempDate);\n  data = temp.shift();\n\n  while (data) {\n    if (data < 0) {\n      data = data + calendarUtil.getYearDaysCount(tempDate, 0) + 1;\n    }\n\n    if (data === yearDay) {\n      return false;\n    }\n\n    data = temp.shift();\n  }\n\n  return true;\n}\n\nfunction getYearDay(currentDate) {\n  if (!startDateCollection[calendarUtil.getFullYear(currentDate)]) {\n    startDateCollection[calendarUtil.getFullYear(currentDate)] = calendarUtil.getYearLastDate(currentDate, 0);\n  }\n\n  var tempDate = startDateCollection[calendarUtil.getFullYear(currentDate)];\n  var diff = currentDate.getTime() - tempDate.getTime();\n  return Math.ceil(diff / MS_PER_DAY);\n}\n\nfunction validateMonthlyRuleType(ruleObject) {\n  if (ruleObject.monthDay.length && !ruleObject.day.length) {\n    return 'date';\n  } else if (!ruleObject.monthDay.length && ruleObject.day.length) {\n    return 'day';\n  }\n\n  return 'both';\n}\n\nfunction rotate(days) {\n  var data = days.shift();\n  days.push(data);\n}\n\nfunction setFirstDayOfWeek(day) {\n  while (dayIndex[0] !== day) {\n    rotate(dayIndex);\n  }\n}\n\nfunction validateRules(tempDate, ruleObject) {\n  var state = true;\n  var expectedDays = ruleObject.day;\n  var expectedMonth = ruleObject.month;\n  var expectedDate = calendarUtil.getExpectedDays(tempDate, ruleObject.monthDay);\n  var expectedyearDay = ruleObject.yearDay;\n  ruleObject.validRules.forEach(function (rule) {\n    switch (rule) {\n      case 'BYDAY':\n        if (checkDayIndex(tempDate.getDay(), expectedDays)) {\n          state = false;\n        }\n\n        break;\n\n      case 'BYMONTH':\n        if (calendarUtil.checkMonth(tempDate, expectedMonth)) {\n          state = false;\n        }\n\n        break;\n\n      case 'BYMONTHDAY':\n        if (checkDate(tempDate, expectedDate)) {\n          state = false;\n        }\n\n        break;\n\n      case 'BYYEARDAY':\n        if (checkYear(tempDate, expectedyearDay)) {\n          state = false;\n        }\n\n        break;\n    }\n  });\n  return state;\n}\n\nexport function getCalendarUtil(calendarMode) {\n  if (calendarMode === 'Islamic') {\n    return new Islamic();\n  }\n\n  return new Gregorian();\n}\nvar startDateCollection = {};\nvar tempExcludeDate;\nvar dayIndex = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\nvar maxOccurrence;\nvar tempViewDate;\nvar calendarUtil;\nvar DAYINDEX = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\nvar MAXOCCURRENCE = 43;\nvar WEEKPOS = ['first', 'second', 'third', 'fourth', 'last'];\nvar TIMES = 'summaryTimes';\nvar ON = 'summaryOn';\nvar EVERY = 'every';\nvar UNTIL = 'summaryUntil';\nvar DAYS = 'summaryDay';\nvar WEEKS = 'summaryWeek';\nvar MONTHS = 'summaryMonth';\nvar YEARS = 'summaryYear';\nvar DAYINDEXOBJECT = {\n  SU: 'sun',\n  MO: 'mon',\n  TU: 'tue',\n  WE: 'wed',\n  TH: 'thu',\n  FR: 'fri',\n  SA: 'sat'\n}; // To check string has number\n\nvar HASNUMBER = /\\d/; // To find the numbers in string\n\nvar REMOVENUMBERINSTRING = /[^A-Z]+/; // To split number and string\n\nvar SPLITNUMBERANDSTRING = /[a-z]+|[^a-z]+/gi;\nexport function getRecurrenceStringFromDate(date) {\n  return [date.getUTCFullYear(), roundDateValues(date.getUTCMonth() + 1), roundDateValues(date.getUTCDate()), 'T', roundDateValues(date.getUTCHours()), roundDateValues(date.getUTCMinutes()), roundDateValues(date.getUTCSeconds()), 'Z'].join('');\n}\n\nfunction roundDateValues(date) {\n  return ('0' + date).slice(-2);\n}","map":null,"metadata":{},"sourceType":"module"}